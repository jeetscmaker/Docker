The Problem with Sensitive Information
========================================
Before digging into Vault, let's try to understand the problem it tries to solve: sensitive information management.

Most applications need access to sensitive data in order to work properly. For instance, an e-commerce application may have a username/password configured 
somewhere in order to connect to its database. It may also need API keys to integrate with other service providers, such as payment gateways, logistics, 
and other business partners.

Database credentials and API Keys are some examples of sensitive information that we need to store and make available to our applications in a secure way.

A simple solution is to store those credentials in a configuration file and read them at startup time. The problem with this approach is obvious, though. 
Whoever has access to this file share the same database privileges our application have – usually giving her full access to all stored data.

We can try to make things a bit harder by encrypting those files. This approach, however, will not add much in terms of overall security. Mainly, because 
our application must have access to the master key. Encryption, when used in this way, will only achieve a “false” sense of security.

Modern applications and cloud environments tend to add some extra complexity: distributed services, multiple databases, messaging systems and so on, all 
have sensitive information spread a bit everywhere, thus increasing the risk of a security breach.

So, what can we do? Let's Vault it!

What Is Vault?
==============
Hashicorp Vault addresses the problem of managing sensitive information – a secret in Vault's parlance. “Managing” in this context means that Vault controls 
all aspects of a sensitive piece of information: its generation, storage, usage and, last but not least, its revocation.

Hashicorp offers two versions of Vault. The open-source version, used in this article, is free to use, even in commercial environments. A paid version is 
also available, which includes technical support at different SLAs and additional features, such as HSM (Hardware Security Module) support.

Architecture & Key Features
=================================
Vault's architecture is deceivingly simple. Its main components are:

A persistence backend – storage for all secrets
An API server which handles client requests and performs operations on secrets
A number of secret engines, one for each type of supported secret type
By delegating all secret handling to Vault, we can mitigate some security issues:

Our applications don't have to store them anymore – just ask Vault when needed and discard it
We can use short-lived secrets, thus limiting the “window of opportunity” where an attacker can use a stolen secret
Vault encrypts all data with an encryption key before writing it to the store. This encryption key is encrypted by yet another key – the master key, used only at startup.

A key point in Vault's implementation is that it doesn't store the master key in the server. This means that not even Vault can access its saved data after startup. 
At this point, a Vault instance is said to be in a “sealed” state.

Later on, we'll go through the steps needed to generate the master key and unseal a Vault instance.

Once unsealed, Vault will be ready to accept API requests. Those requests, of course, need authentication, which brings us to how Vault authenticates 
clients and decides what they can or can't do.